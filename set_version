#!/usr/bin/python
# -*- coding: utf-8 -*-

# A simple script to update version number in spec, dsc or arch linux files
#
# (C) 2010 by Adrian Schr√∂ter <adrian@suse.de>
# (C) 2015 by Thomas Bechtold <tbechtold@suse.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# See http://www.gnu.org/licenses/gpl-2.0.html for full license text.


import argparse
import glob
import os
import re
import shutil
import sys
import tarfile
import zipfile


suffixes = ('tar', 'tar.gz', 'tgz', 'tar.bz2', 'tbz2', 'tar.xz', 'zip')
suffixes_re = "|".join(map(lambda x: re.escape(x), suffixes))


def _get_local_files():
    """ sorted local file list by modification time (newest first)"""
    files = glob.glob('*')
    files.sort(key=lambda x: os.stat(os.path.join(os.getcwd(), x)).st_mtime,
               reverse=True)
    return files


class VersionDetector(object):
    @staticmethod
    def _autodetect(files, basename):
        version = None
        version = VersionDetector._get_version_via_filename(
            files, basename)
        if not version:
            version = VersionDetector._get_version_via_archive_dirname(
                files, basename)
        if not version:
            version = VersionDetector._get_version_via_debian_changelog(
                "debian.changelog")
        return version

    @staticmethod
    def _get_version_via_filename(files, basename):
        """ detect version based on file names"""
        for f in files:
            regex = r"^%s.*[-_]([\d].*)\.(?:%s)$" % (re.escape(basename),
                                                     suffixes_re)
            m = re.match(regex, f)
            if m:
                return m.group(1)
        # Nothing found
        return None

    @staticmethod
    def __get_version(str_list, basename):
        regex = "%s.*[-_]([\d][^\/]*).*" % basename
        for s in str_list:
            m = re.match(regex, s)
            if m:
                return m.group(1)
        # Nothing found
        return None

    @staticmethod
    def _get_version_via_archive_dirname(files, basename):
        """ detect version based tar'd directory name"""
        for f in filter(lambda x: x.endswith(suffixes), files):
            # handle tarfiles
            if tarfile.is_tarfile(f):
                with tarfile.open(f) as tf:
                    v = VersionDetector.__get_version(tf.getnames(), basename)
                    if v:
                        return v
            # handle zipfiles
            if zipfile.is_zipfile(f):
                with zipfile.ZipFile(f, 'r') as zf:
                    v = VersionDetector.__get_version(zf.namelist(), basename)
                    if v:
                        return v
        # Nothing found
        return None

    @staticmethod
    def _get_version_via_debian_changelog(filename):
        # from http://anonscm.debian.org/cgit/pkg-python-debian/\
            # python-debian.git/tree/lib/debian/changelog.py
        topline = re.compile(r'^(\w%(name_chars)s*) \(([^\(\) \t]+)\)'
                             '((\s+%(name_chars)s+)+)\;'
                             % {'name_chars': '[-+0-9a-z.]'},
                             re.IGNORECASE)
        if os.path.exists(filename):
            with open(filename, "r") as f:
                firstline = f.readline()
                topmatch = topline.match(firstline)
                if topmatch:
                    return topmatch.group(2)
        # Nothing found
        return None


def _replace_tag(filename, tag, string):
    # first, modify a copy of filename and then move it
    filename_new = ".%s" % filename
    shutil.copy(filename, filename_new)
    with open(filename_new, 'r+') as f:
        contents = f.read()
        f.seek(0)
        if filename.endswith("PKGBUILD"):
            contents_new, subs = re.subn(
                r"^{tag}=.*".format(tag=tag),
                r"{tag}={string}".format(tag=tag, string=string), contents)
        else:
            # keep inline macros for rpm
            contents_new, subs = re.subn(r'^{tag}:(\s*)[^%]*'.format(tag=tag),
                                         r'{tag}:\g<1>{string}'.format(
                                             tag=tag, string=string), contents)

        if subs > 0:
            f.truncate()
            f.write(contents_new)
    os.rename(filename_new, filename)


def _replace_debian_changelog_version(filename, version_new):
    # first, modify a copy of filename and then move it
    filename_new = ".%s" % filename
    shutil.copy(filename, filename_new)
    # get current version
    version_current = VersionDetector._get_version_via_debian_changelog(
        filename_new)
    with open(filename_new, 'r+') as f:
        content_lines = f.readlines()
        f.seek(0)
        content_lines[0] = content_lines[0].replace(
            version_current, version_new, 1)
        f.truncate()
        f.writelines(content_lines)
    os.rename(filename_new, filename)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Open Build Service source service "set_version".'
        'Used to update build description files with a '
        'detected or given version number.')
    parser.add_argument('--outdir', required=True,
                        help='output directory for modified sources')
    parser.add_argument('--version',
                        help='use given version string, do not detect it '
                        'from source files')
    parser.add_argument('--basename', default="",
                        help='detect version based on the file name with '
                        'a given prefix')
    parser.add_argument('--file', action='append',
                        help='modify only this build description. '
                        'maybe used multiple times.')
    args = vars(parser.parse_args())

    version = args['version']

    files_local = _get_local_files()

    if not version:
        version = VersionDetector._autodetect(files_local, args["basename"])

    if not version:
        sys.exit(-1)

    # if no files explicitly specified process whole directory
    files = args['file'] or files_local

    # handle rpm spec and debian dsc files
    for f in filter(lambda x: x.endswith((".spec", ".dsc")), files):
        _replace_tag(f, 'Version', version)
        _replace_tag(f, 'Release', "0")

    # update debian.changelog file
    for f in filter(lambda x: x.endswith(("debian.changelog")), files):
        _replace_debian_changelog_version(f, version)

    # handle arch linux PKGBUILD files
    # TODO: Handle the md5sums generation!
    for f in filter(lambda x: x.endswith(("PKGBUILD")), files):
        _replace_tag(f, "md5sums", "(SKIP)")
